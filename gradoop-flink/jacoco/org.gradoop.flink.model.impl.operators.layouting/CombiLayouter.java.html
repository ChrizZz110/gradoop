<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CombiLayouter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop Flink</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.flink.model.impl.operators.layouting</a> &gt; <span class="el_source">CombiLayouter.java</span></div><h1>CombiLayouter.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2021 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.flink.model.impl.operators.layouting;

import org.gradoop.flink.model.impl.epgm.LogicalGraph;

/**
 * A layouter that combines the {@link CentroidFRLayouter } and the {@link FRLayouter}.
 */
public class CombiLayouter implements LayoutingAlgorithm {
  /**
   * Factor by which the k of the CentroidFRLayouter is scaled
   */
  private static final double K_FACTOR = 1.3;
  /**
   * Number of iterations to perform
   */
  private int iterations;
  /**
   * Approximate number of vertices in the input-graph
   */
  private int numberOfVertices;
  /**
   * The ratio of iterations of the CentroidFRLayouter and the FRLayouter
   */
  private double quality;
  /**
   * The CentroidFRLayouter that is being used
   */
  private CentroidFRLayouter centroidFRLayouter;
  /**
   * The FRLayouter that is being used
   */
  private FRLayouter fRLayouter;

  /**
   * Create a new CombiLayouter.
   *
   * @param iterations  Number of iterations to perform
   * @param numVertices Approximate number of vertices in the input-graph
   * @param quality     Ratio of iterations between the two base algorithms. The higher the value,
   *                    the more iterations of the FRLayouter are performed. A value of 0.1 is often
   *                    good enough.
   */
<span class="nc" id="L58">  public CombiLayouter(int iterations, int numVertices, double quality) {</span>

<span class="nc" id="L60">    this.iterations = iterations;</span>
<span class="nc" id="L61">    this.numberOfVertices = numVertices;</span>
<span class="nc" id="L62">    this.quality = quality;</span>
<span class="nc" id="L63">    int centroidIterations = (int) Math.floor(iterations * (1 - quality));</span>
<span class="nc" id="L64">    int frIterations = (int) Math.ceil(iterations * quality);</span>

<span class="nc bnc" id="L66" title="All 2 branches missed.">    if (centroidIterations &gt; 0) {</span>
<span class="nc" id="L67">      centroidFRLayouter = new CentroidFRLayouter(centroidIterations, numVertices);</span>
<span class="nc" id="L68">      centroidFRLayouter.k(centroidFRLayouter.getK() * K_FACTOR);</span>
    }
<span class="nc bnc" id="L70" title="All 2 branches missed.">    if (frIterations &gt; 0) {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">      fRLayouter =</span>
<span class="nc" id="L72">        new FRLayouter(frIterations, numVertices).useExistingLayout(centroidFRLayouter != null)</span>
<span class="nc" id="L73">          .startAtIteration(centroidIterations);</span>
    }
<span class="nc" id="L75">  }</span>

  /**
   * Set the FRLayouter parameter k for both algorithms, overwriting the default value
   *
   * @param k The new value
   * @return this layouter
   */
  public CombiLayouter k(double k) {
<span class="nc bnc" id="L84" title="All 2 branches missed.">    if (centroidFRLayouter != null) {</span>
<span class="nc" id="L85">      centroidFRLayouter.k(k * K_FACTOR);</span>
    }
<span class="nc bnc" id="L87" title="All 2 branches missed.">    if (fRLayouter != null) {</span>
<span class="nc" id="L88">      fRLayouter.k(k);</span>
    }
<span class="nc" id="L90">    return this;</span>
  }

  /**
   * Override default layout-space size
   * Default:  {@code width = height = Math.sqrt(Math.pow(k, 2) * numberOfVertices) * 0.5}
   *
   * @param width  new width
   * @param height new height
   * @return this layouter
   */
  public CombiLayouter area(int width, int height) {
<span class="nc bnc" id="L102" title="All 2 branches missed.">    if (centroidFRLayouter != null) {</span>
<span class="nc" id="L103">      centroidFRLayouter.area(width, height);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">      if (fRLayouter != null) {</span>
<span class="nc" id="L105">        fRLayouter.area(width, height);</span>
      }
    }
<span class="nc" id="L108">    return this;</span>
  }

  /**
   * Override default maxRepulsionDistance of the FR-Algorithm. Vertices with larger distance
   * are ignored in repulsion-force calculation
   * Default-Value is relative to current {@code k}. If {@code k} is overriden, this is changed
   * accordingly automatically
   * Default: 2k
   *
   * @param maxRepulsionDistance new value
   * @return this layouter
   */
  public CombiLayouter maxRepulsionDistance(int maxRepulsionDistance) {
<span class="nc bnc" id="L122" title="All 2 branches missed.">    if (fRLayouter != null) {</span>
<span class="nc" id="L123">      fRLayouter.maxRepulsionDistance(maxRepulsionDistance);</span>
    }
<span class="nc" id="L125">    return this;</span>
  }

  /**
   * Use the existing layout as starting point instead of creating a random one.
   * If used, EVERY vertex in the input-graph MUST have an X and Y property!
   *
   * @param useExisting whether to re-use the existing layout or not
   * @return this layouter
   */
  public CombiLayouter useExistingLayout(boolean useExisting) {
<span class="nc bnc" id="L136" title="All 2 branches missed.">    if (centroidFRLayouter != null) {</span>
<span class="nc" id="L137">      centroidFRLayouter.useExistingLayout(useExisting);</span>
    } else {
<span class="nc" id="L139">      fRLayouter.useExistingLayout(useExisting);</span>
    }
<span class="nc" id="L141">    return this;</span>
  }

  /**
   * Gets k. K is the distance in which the attracting and repulsive forces between two connected
   * vertices are equally strong. The value of k influences the scale of the final graph-layout.
   * (A small k leads to vertices being closer together)
   *
   * @return value of k
   */
  public double getK() {
<span class="nc bnc" id="L152" title="All 2 branches missed.">    if (fRLayouter != null) {</span>
<span class="nc" id="L153">      return fRLayouter.getK();</span>
    } else {
<span class="nc" id="L155">      return centroidFRLayouter.getK() / K_FACTOR;</span>
    }
  }

  /**
   * Gets maxRepulsionDistance
   *
   * @return value of maxRepulsionDistance
   */
  public int getMaxRepulsionDistance() {
<span class="nc bnc" id="L165" title="All 2 branches missed.">    if (fRLayouter == null) {</span>
<span class="nc" id="L166">      return -1;</span>
    }
<span class="nc" id="L168">    return fRLayouter.getMaxRepulsionDistance();</span>
  }

  @Override
  public LogicalGraph execute(LogicalGraph g) {
<span class="nc bnc" id="L173" title="All 2 branches missed.">    if (centroidFRLayouter != null) {</span>
<span class="nc" id="L174">      g = centroidFRLayouter.execute(g);</span>
    }
<span class="nc bnc" id="L176" title="All 2 branches missed.">    if (fRLayouter != null) {</span>
<span class="nc" id="L177">      g = fRLayouter.execute(g);</span>
    }
<span class="nc" id="L179">    return g;</span>
  }

  @Override
  public int getWidth() {
<span class="nc bnc" id="L184" title="All 2 branches missed.">    if (fRLayouter != null) {</span>
<span class="nc" id="L185">      return fRLayouter.getWidth();</span>
    } else {
<span class="nc" id="L187">      return centroidFRLayouter.getWidth();</span>
    }
  }

  @Override
  public int getHeight() {
<span class="nc bnc" id="L193" title="All 2 branches missed.">    if (fRLayouter != null) {</span>
<span class="nc" id="L194">      return fRLayouter.getHeight();</span>
    } else {
<span class="nc" id="L196">      return centroidFRLayouter.getHeight();</span>
    }
  }

  @Override
  public String toString() {
<span class="nc" id="L202">    return &quot;CombiFRLayouter{&quot; + &quot; quality=&quot; + quality + &quot;, iterations=&quot; + iterations + &quot;, k=&quot; +</span>
<span class="nc" id="L203">      getK() + &quot;,&quot; + &quot; &quot; + &quot;with=&quot; + getWidth() + &quot;, height=&quot; + getHeight() +</span>
<span class="nc" id="L204">      &quot;, maxRepulsionDistance=&quot; + getMaxRepulsionDistance() + &quot;, numberOfVertices=&quot; +</span>
      numberOfVertices + '}';
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>