<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EmbeddingMetaData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop Flink</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.flink.model.impl.operators.matching.single.cypher.pojos</a> &gt; <span class="el_source">EmbeddingMetaData.java</span></div><h1>EmbeddingMetaData.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2021 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.flink.model.impl.operators.matching.single.cypher.pojos;

import org.apache.commons.lang3.tuple.Pair;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.utils.ExpandDirection;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * This class stores meta data information about a data set of {@link Embedding} objects.
 *
 * An {@link Embedding} stores identifiers (single or path) and properties associated with query
 * elements.
 *
 * The meta data contains a mapping between query variables and the column index storing the
 * associated element/path identifier. Furthermore, the meta data object contains a mapping between
 * property values associated to property keys at query elements.
 */
public class EmbeddingMetaData implements Serializable {
  /**
   * Describes the type of an embedding entry
   */
<span class="fc" id="L46">  public enum EntryType {</span>
    /**
     * Vertex
     */
<span class="fc" id="L50">    VERTEX,</span>
    /**
     * Edge
     */
<span class="fc" id="L54">    EDGE,</span>
    /**
     * Path
     */
<span class="fc" id="L58">    PATH</span>
  }

  /**
   * Stores the mapping of query variables to embedding entries
   */
  private Map&lt;Pair&lt;String, EntryType&gt;, Integer&gt; entryMapping;
  /**
   * Stores where the corresponding PropertyValue of a Variable-PropertyKey-Pair is stored within
   * the embedding
   */
  private Map&lt;Pair&lt;String, String&gt;, Integer&gt; propertyMapping;
  /**
   * Stores the direction in which paths are stored in the embedding
   */
  private Map&lt;String, ExpandDirection&gt; directionMapping;


  /**
   * Initialises an empty EmbeddingMetaData object
   */
  public EmbeddingMetaData() {
<span class="fc" id="L80">    this(new HashMap&lt;&gt;(), new HashMap&lt;&gt;(), new HashMap&lt;&gt;());</span>
<span class="fc" id="L81">  }</span>

  /**
   * Initializes a new EmbeddingMetaData object from the given mappings
   *
   * @param entryMapping maps variables to embedding entries
   * @param propertyMapping maps variable-propertyKey pairs to embedding property data entries
   * @param directionMapping maps (path) variables to their direction
   */
  public EmbeddingMetaData(Map&lt;Pair&lt;String, EntryType&gt;, Integer&gt; entryMapping,
    Map&lt;Pair&lt;String, String&gt;, Integer&gt; propertyMapping,
<span class="fc" id="L92">    Map&lt;String, ExpandDirection&gt; directionMapping) {</span>
<span class="fc" id="L93">    this.entryMapping = entryMapping;</span>
<span class="fc" id="L94">    this.propertyMapping = propertyMapping;</span>
<span class="fc" id="L95">    this.directionMapping = directionMapping;</span>
<span class="fc" id="L96">  }</span>

  /**
   * Initializes a new EmbeddingMetaData object using copies of the provided meta data.
   *
   * @param metaData meta data to be copied
   */
<span class="fc" id="L103">  public EmbeddingMetaData(EmbeddingMetaData metaData) {</span>
<span class="fc" id="L104">    this.entryMapping = new HashMap&lt;&gt;(metaData.getEntryCount());</span>
<span class="fc" id="L105">    this.propertyMapping = new HashMap&lt;&gt;(metaData.getPropertyCount());</span>
<span class="fc" id="L106">    this.directionMapping = new HashMap&lt;&gt;(metaData.getPathCount());</span>

<span class="fc" id="L108">    metaData.getVariables().forEach(var -&gt; {</span>
<span class="fc" id="L109">      this.entryMapping.put(</span>
<span class="fc" id="L110">        Pair.of(var, metaData.getEntryType(var)), metaData.getEntryColumn(var));</span>
<span class="fc" id="L111">      metaData.getPropertyKeys(var).forEach(key -&gt;</span>
<span class="fc" id="L112">        this.propertyMapping.put(Pair.of(var, key), metaData.getPropertyColumn(var, key)));</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">      if (metaData.getEntryType(var) == EntryType.PATH) {</span>
<span class="fc" id="L114">        this.directionMapping.put(var, metaData.getDirection(var));</span>
      }
<span class="fc" id="L116">    });</span>
<span class="fc" id="L117">  }</span>

  public Map&lt;Pair&lt;String, EntryType&gt;, Integer&gt; getEntryMapping() {
<span class="nc" id="L120">    return this.entryMapping;</span>
  }

  public Map&lt;Pair&lt;String, String&gt;, Integer&gt; getPropertyMapping() {
<span class="nc" id="L124">    return propertyMapping;</span>
  }

  public Map&lt;String, ExpandDirection&gt; getDirectionMapping() {
<span class="fc" id="L128">    return directionMapping;</span>
  }

  /**
   * Returns the number of entries mapped in this meta data.
   *
   * @return number of mapped entries
   */
  public int getEntryCount() {
<span class="fc" id="L137">    return entryMapping.size();</span>
  }

  /**
   * Returns the number of property values mapped in this meta data.
   *
   * @return number of mapped property values
   */
  public int getPropertyCount() {
<span class="fc" id="L146">    return propertyMapping.size();</span>
  }

  /**
   * Returns the number of variable length paths mapped in this meta data.
   *
   * @return number of variable length paths
   */
  public int getPathCount() {
<span class="fc" id="L155">    return directionMapping.size();</span>
  }

  /**
   * Inserts or updates a column mapping entry
   *
   * @param variable referenced variable
   * @param entryType entry type
   * @param column corresponding embedding entry index
   */
  public void setEntryColumn(String variable, EntryType entryType, int column) {
<span class="fc" id="L166">    entryMapping.put(Pair.of(variable, entryType), column);</span>
<span class="fc" id="L167">  }</span>

  /**
   * Returns the position of the embedding entry corresponding to the given variable.
   * The method checks if the variable is mapped to a vertex or an edge entry.
   *
   * @param variable variable name
   * @return the position of the corresponding embedding entry
   * @throws NoSuchElementException if there is no column mapped to the specified variable
   */
  public int getEntryColumn(String variable) {
<span class="fc" id="L178">    return entryMapping.get(Pair.of(variable, getEntryType(variable)));</span>
  }

  /**
   * Checks if the specified variable is mapped to a column in the embedding.
   *
   * @param variable query variable
   * @return true, iff the variable is mapped to a column
   */
  public boolean containsEntryColumn(String variable) {
<span class="fc" id="L188">    return Arrays.stream(EntryType.values())</span>
<span class="fc" id="L189">      .anyMatch(entryType -&gt; entryMapping.containsKey(Pair.of(variable, entryType)));</span>
  }

  /**
   * Returns the entry type of the given variable.
   *
   * @param variable query variable
   * @return Entry type of the referred entry
   * @throws NoSuchElementException if there is no column mapped to the specified variable
   */
  public EntryType getEntryType(String variable) {
<span class="fc" id="L200">    Optional&lt;EntryType&gt; result = Arrays.stream(EntryType.values())</span>
<span class="fc" id="L201">      .filter(entryType -&gt; entryMapping.containsKey(Pair.of(variable, entryType)))</span>
<span class="fc" id="L202">      .findFirst();</span>

<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (!result.isPresent()) {</span>
<span class="fc" id="L205">      throw new NoSuchElementException(String.format(&quot;no entry for variable %s&quot;, variable));</span>
    }
<span class="fc" id="L207">    return result.get();</span>
  }

  /**
   * Inserts or updates the mapping of a Variable-PropertyKey pair to the position of the
   * corresponding PropertyValue within the embeddings propertyData array
   *
   * @param variable variable name
   * @param propertyKey property key
   * @param index position of the property value within the propertyData array
   */
  public void setPropertyColumn(String variable, String propertyKey, int index) {
<span class="fc" id="L219">    propertyMapping.put(Pair.of(variable, propertyKey), index);</span>
<span class="fc" id="L220">  }</span>

  /**
   * Returns the position of the PropertyValue corresponding to the Variable-PropertyKey-Pair.
   *
   * @param variable variable name
   * @param propertyKey property key
   * @return the position of the corresponding property value
   * @throws NoSuchElementException if there is no column mapped to the given variable and key
   */
  public int getPropertyColumn(String variable, String propertyKey) {
<span class="fc" id="L231">    Integer column = propertyMapping.get(Pair.of(variable, propertyKey));</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">    if (column == null) {</span>
<span class="fc" id="L233">      throw new NoSuchElementException(</span>
<span class="fc" id="L234">        String.format(&quot;no value for property %s.%s&quot;, variable, propertyKey));</span>
    }
<span class="fc" id="L236">    return column;</span>
  }

  /**
   * Inserts or updates the direction for the specified path variable.
   *
   * @param variable variable associated with a variable length path
   * @param direction direction in which the path is stored in the embedding
   */
  public void setDirection(String variable, ExpandDirection direction) {
<span class="fc" id="L246">    directionMapping.put(variable, direction);</span>
<span class="fc" id="L247">  }</span>

  /**
   * Returns the direction in which the path associated with the specified variable is stored
   * in the embedding.
   *
   * @param variable variable associated with a variable length path
   * @return direction
   * @throws NoSuchElementException if the variable has no assigned direction
   */
  public ExpandDirection getDirection(String variable) {
<span class="fc" id="L258">    ExpandDirection expandDirection = directionMapping.get(variable);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">    if (expandDirection == null) {</span>
<span class="fc" id="L260">      throw new NoSuchElementException(&quot;No direction for: &quot; + variable);</span>
    }
<span class="fc" id="L262">    return expandDirection;</span>
  }

  /**
   * Returns a list of all variable that are contained in the embedding.
   * The order of the variables is determined by their position within the embedding.
   *
   * @return a list of all variables
   */
  public List&lt;String&gt; getVariables() {
<span class="fc" id="L272">    return entryMapping.entrySet().stream()</span>
<span class="fc" id="L273">      .sorted(Comparator.comparingInt(Map.Entry::getValue))</span>
<span class="fc" id="L274">      .map(entry -&gt; entry.getKey().getLeft())</span>
<span class="fc" id="L275">      .collect(Collectors.toList());</span>
  }

  /**
   * Returns a list of all variables that are contained in the embedding and have at least one
   * associated property column.
   *
   * @return a list of all variables with at least one property column
   */
  public List&lt;String&gt; getVariablesWithProperties() {
<span class="fc" id="L285">    return propertyMapping.keySet().stream()</span>
<span class="fc" id="L286">      .map(Pair::getLeft)</span>
<span class="fc" id="L287">      .distinct()</span>
<span class="fc" id="L288">      .collect(Collectors.toList());</span>
  }

  /**
   * Returns a list of variables that are contained in the embedding and refer to vertices. The
   * order of the variables is determined by their position within the embedding.
   *
   * @return a list of all vertex variables
   */
  public List&lt;String&gt; getVertexVariables() {
<span class="fc bfc" id="L298" title="All 2 branches covered.">    return getVariables(entry -&gt; entry == EntryType.VERTEX);</span>
  }

  /**
   * Returns a list of variables that are contained in the embedding and refer to edges. The
   * order of the variables is determined by their position within the embedding.
   *
   * @return a list of all edge variables
   */
  public List&lt;String&gt; getEdgeVariables() {
<span class="fc bfc" id="L308" title="All 2 branches covered.">    return getVariables(entry -&gt; entry == EntryType.EDGE);</span>
  }

  /**
   * Returns a list of variables that are contained in the embedding and refer to paths. The order
   * of the variables is determined by their position within the embedding.
   *
   * @return a list of all path variables
   */
  public List&lt;String&gt; getPathVariables() {
<span class="fc bfc" id="L318" title="All 2 branches covered.">    return getVariables(entry -&gt; entry == EntryType.PATH);</span>
  }

  /**
   * Returns a list of all property keys that are contained in the embedding regarding the
   * specified variable.
   * The order of the keys is determined by the position of the property value in the embedding.
   *
   * @param variable variable name
   * @return a list of all property keys contained in the embedding
   */
  public List&lt;String&gt; getPropertyKeys(String variable) {
<span class="fc" id="L330">    return propertyMapping.entrySet().stream()</span>
<span class="fc" id="L331">      .filter(entry -&gt; entry.getKey().getLeft().equals(variable))</span>
<span class="fc" id="L332">      .sorted(Comparator.comparingInt(Map.Entry::getValue))</span>
<span class="fc" id="L333">      .map(entry -&gt; entry.getKey().getRight())</span>
<span class="fc" id="L334">      .collect(Collectors.toList());</span>
  }

  @Override
  public boolean equals(Object o) {
<span class="fc bfc" id="L339" title="All 2 branches covered.">    if (this == o) {</span>
<span class="fc" id="L340">      return true;</span>
    }
<span class="pc bpc" id="L342" title="2 of 4 branches missed.">    if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L343">      return false;</span>
    }

<span class="fc" id="L346">    EmbeddingMetaData metaData = (EmbeddingMetaData) o;</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">    return entryMapping.equals(metaData.entryMapping) &amp;&amp;</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">      propertyMapping.equals(metaData.propertyMapping);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L354">    return 31 * entryMapping.hashCode() + propertyMapping.hashCode();</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L359">    List&lt;Map.Entry&lt;Pair&lt;String, EntryType&gt;, Integer&gt;&gt; sortedEntries = entryMapping.entrySet()</span>
<span class="nc" id="L360">      .stream()</span>
<span class="nc" id="L361">      .sorted(Comparator.comparingInt(Map.Entry::getValue))</span>
<span class="nc" id="L362">      .collect(Collectors.toList());</span>

<span class="nc" id="L364">    List&lt;Map.Entry&lt;Pair&lt;String, String&gt;, Integer&gt;&gt; sortiedProperties = propertyMapping.entrySet()</span>
<span class="nc" id="L365">      .stream()</span>
<span class="nc" id="L366">      .sorted(Comparator.comparingInt(Map.Entry::getValue))</span>
<span class="nc" id="L367">      .collect(Collectors.toList());</span>

<span class="nc" id="L369">    return String.format(&quot;EmbeddingMetaData{entryMapping=%s, propertyMapping=%s}&quot;,</span>
      sortedEntries, sortiedProperties);
  }

  /**
   * Returns the variables that fulfil the specified predicate. The variables are ordered by
   * their appearance in the entry mapping.
   *
   * @param predicate predicate for entry types
   * @return variables that fulfil the predicate
   */
  private List&lt;String&gt; getVariables(Predicate&lt;EntryType&gt; predicate) {
<span class="fc" id="L381">    return entryMapping.entrySet().stream()</span>
<span class="fc" id="L382">      .filter(entry -&gt; predicate.test(entry.getKey().getRight()))</span>
<span class="fc" id="L383">      .sorted(Comparator.comparingInt(Map.Entry::getValue))</span>
<span class="fc" id="L384">      .map(entry -&gt; entry.getKey().getLeft())</span>
<span class="fc" id="L385">      .collect(Collectors.toList());</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>