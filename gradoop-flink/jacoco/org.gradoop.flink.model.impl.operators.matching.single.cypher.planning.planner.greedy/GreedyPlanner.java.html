<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GreedyPlanner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop Flink</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.planner.greedy</a> &gt; <span class="el_source">GreedyPlanner.java</span></div><h1>GreedyPlanner.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2021 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.planner.greedy;

import com.google.common.collect.Sets;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.flink.api.java.DataSet;
import org.gradoop.common.model.api.entities.GraphHead;
import org.gradoop.common.util.GradoopConstants;
import org.gradoop.flink.model.api.epgm.BaseGraph;
import org.gradoop.flink.model.api.epgm.BaseGraphCollection;
import org.gradoop.flink.model.impl.operators.matching.common.MatchStrategy;
import org.gradoop.flink.model.impl.operators.matching.common.query.QueryHandler;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.CNF;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.CNFElement;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.QueryComparable;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.comparables.PropertySelectorComparable;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.expressions.ComparisonExpression;
import org.gradoop.flink.model.impl.operators.matching.common.statistics.GraphStatistics;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.utils.ExpandDirection;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.estimation.QueryPlanEstimator;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTable;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.PlanNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.QueryPlan;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.binary.CartesianProductNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.binary.ExpandEmbeddingsNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.binary.JoinEmbeddingsNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.binary.ValueJoinNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.leaf.FilterAndProjectEdgesNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.leaf.FilterAndProjectVerticesNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.unary.FilterEmbeddingsNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.unary.ProjectEmbeddingsNode;
import org.gradoop.gdl.model.Edge;
import org.gradoop.gdl.model.Vertex;
import org.gradoop.gdl.utils.Comparator;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry.Type.EDGE;
import static org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry.Type.GRAPH;
import static org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry.Type.PATH;
import static org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry.Type.VERTEX;

/**
 * A greedy query planner that builds a query plan by iteratively picking the cheapest partial query
 * plan and extending it.
 *
 * @param &lt;G&gt; The graph head type.
 * @param &lt;V&gt; The vertex type.
 * @param &lt;E&gt; The edge type.
 * @param &lt;LG&gt; The graph type.
 * @param &lt;GC&gt; The graph collection type.
 */
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">public class GreedyPlanner&lt;</span>
  G extends GraphHead,
  V extends org.gradoop.common.model.api.entities.Vertex,
  E extends org.gradoop.common.model.api.entities.Edge,
  LG extends BaseGraph&lt;G, V, E, LG, GC&gt;,
  GC extends BaseGraphCollection&lt;G, V, E, LG, GC&gt;&gt; {

  /**
   * The search graph to be queried
   */
  private final LG graph;
  /**
   * The query handler represents the query.
   */
  private final QueryHandler queryHandler;
  /**
   * Statistics about the search graph.
   */
  private final GraphStatistics graphStatistics;
  /**
   * The morphism type for vertex mappings.
   */
  private final MatchStrategy vertexStrategy;
  /**
   * The morphism type for edge mappings.
   */
  private final MatchStrategy edgeStrategy;

  /**
   * Creates a new greedy planner.
   *
   * @param graph search graph
   * @param queryHandler query handler
   * @param graphStatistics search graph statistics
   * @param vertexStrategy morphism type for vertex mappings
   * @param edgeStrategy morphism type for edge mappings
   */
  public GreedyPlanner(LG graph, QueryHandler queryHandler,
<span class="fc" id="L110">    GraphStatistics graphStatistics, MatchStrategy vertexStrategy, MatchStrategy edgeStrategy) {</span>
<span class="fc" id="L111">    this.graph = graph;</span>
<span class="fc" id="L112">    this.queryHandler = queryHandler;</span>
<span class="fc" id="L113">    this.graphStatistics = graphStatistics;</span>
<span class="fc" id="L114">    this.vertexStrategy = vertexStrategy;</span>
<span class="fc" id="L115">    this.edgeStrategy = edgeStrategy;</span>
<span class="fc" id="L116">  }</span>

  /**
   * Computes the {@link PlanTableEntry} that wraps the {@link QueryPlan} with the minimum costs
   * according to the greedy optimization algorithm.
   *
   * @return entry with minimum execution costs
   */
  public PlanTableEntry plan() {
<span class="fc" id="L125">    PlanTable planTable = initPlanTable();</span>

<span class="fc bfc" id="L127" title="All 2 branches covered.">    while (planTable.size() &gt; 1) {</span>
<span class="fc" id="L128">      PlanTable newPlans = evaluateJoins(planTable);</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">      if (newPlans.size() == 0) {</span>
        // No new plans where generated by joining but there are still multiple disconnected
        // query graph components. In this case we need to do a cartesian product.
<span class="fc" id="L133">        newPlans = evaluateCartesianProducts(planTable);</span>
      }
<span class="fc" id="L135">      newPlans = evaluateFilter(newPlans);</span>
<span class="fc" id="L136">      newPlans = evaluateProjection(newPlans);</span>

      // get plan with minimum costs and remove all plans covered by this plan
<span class="fc" id="L139">      PlanTableEntry bestEntry = newPlans.min();</span>
<span class="fc" id="L140">      planTable.removeCoveredBy(bestEntry);</span>
<span class="fc" id="L141">      planTable.add(bestEntry);</span>
<span class="fc" id="L142">    }</span>

<span class="fc" id="L144">    return planTable.get(0);</span>
  }

  //------------------------------------------------------------------------------------------------
  // Initialization
  //------------------------------------------------------------------------------------------------

  /**
   * Creates the initial plan table entries according to the specified vertices and edges.
   *
   * @return initial plan table
   */
  private PlanTable initPlanTable() {
<span class="fc" id="L157">    PlanTable planTable = new PlanTable();</span>
<span class="fc" id="L158">    createVertexPlans(planTable);</span>
<span class="fc" id="L159">    createEdgePlans(planTable);</span>
<span class="fc" id="L160">    return planTable;</span>
  }

  //------------------------------------------------------------------------------------------------
  // Leaf nodes (i.e. vertices and (variable length) edges)
  //------------------------------------------------------------------------------------------------

  /**
   * Creates an initial {@link PlanTableEntry} for each vertex in the query graph and adds it to the
   * specified {@link PlanTable}. The entry wraps a query plan that filters vertices based on their
   * predicates and projects properties that are required for further query planning.
   *
   * @param planTable plan table
   */
  private void createVertexPlans(PlanTable planTable) {
<span class="fc bfc" id="L175" title="All 2 branches covered.">    for (Vertex vertex : queryHandler.getVertices()) {</span>
<span class="fc" id="L176">      String vertexVariable = vertex.getVariable();</span>
<span class="fc" id="L177">      CNF allPredicates = queryHandler.getPredicates();</span>
      // TODO: this might be moved to the FilterAndProject node in issue #510
<span class="fc" id="L179">      CNF vertexPredicates = allPredicates.removeSubCNF(vertexVariable);</span>
<span class="fc" id="L180">      Set&lt;String&gt; projectionKeys = allPredicates.getPropertyKeys(vertexVariable);</span>

<span class="fc" id="L182">      DataSet&lt;V&gt; vertices =</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        vertex.getLabel().equals(GradoopConstants.DEFAULT_VERTEX_LABEL) ?</span>
<span class="fc" id="L184">          graph.getVertices() : graph.getVerticesByLabel(vertex.getLabel());</span>

<span class="fc" id="L186">      FilterAndProjectVerticesNode&lt;V&gt; node = new FilterAndProjectVerticesNode&lt;&gt;(vertices,</span>
<span class="fc" id="L187">        vertex.getVariable(), vertexPredicates, projectionKeys);</span>

<span class="fc" id="L189">      planTable.add(new PlanTableEntry(VERTEX, Sets.newHashSet(vertexVariable), allPredicates,</span>
        new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)));
<span class="fc" id="L191">    }</span>
<span class="fc" id="L192">  }</span>

  /**
   * Creates an initial {@link PlanTableEntry} for each edge in the query graph and adds it to the
   * specified {@link PlanTable}. The entry wraps a {@link QueryPlan} that filters edges based on
   * their predicates and projects properties that are required for further query planning.
   *
   * @param planTable plan table
   */
  private void createEdgePlans(PlanTable planTable) {
<span class="fc bfc" id="L202" title="All 2 branches covered.">    for (Edge edge : queryHandler.getEdges()) {</span>
<span class="fc" id="L203">      String edgeVariable = edge.getVariable();</span>
<span class="fc" id="L204">      String sourceVariable = queryHandler.getVertexById(edge.getSourceVertexId()).getVariable();</span>
<span class="fc" id="L205">      String targetVariable = queryHandler.getVertexById(edge.getTargetVertexId()).getVariable();</span>

<span class="fc" id="L207">      CNF allPredicates = queryHandler.getPredicates();</span>
      // TODO: this might be moved the the FilterAndProject node in issue #510
<span class="fc" id="L209">      CNF edgePredicates = allPredicates.removeSubCNF(edgeVariable);</span>
<span class="fc" id="L210">      Set&lt;String&gt; projectionKeys = allPredicates.getPropertyKeys(edgeVariable);</span>

<span class="fc bfc" id="L212" title="All 2 branches covered.">      boolean isPath = edge.getUpperBound() != 1;</span>

<span class="fc" id="L214">      DataSet&lt;E&gt; edges =</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        edge.getLabel().equals(GradoopConstants.DEFAULT_EDGE_LABEL) ?</span>
<span class="fc" id="L216">          graph.getEdges() : graph.getEdgesByLabel(edge.getLabel());</span>

<span class="fc" id="L218">      FilterAndProjectEdgesNode&lt;E&gt; node = new FilterAndProjectEdgesNode&lt;&gt;(edges,</span>
        sourceVariable, edgeVariable, targetVariable, edgePredicates, projectionKeys, isPath);

<span class="fc bfc" id="L221" title="All 2 branches covered.">      PlanTableEntry.Type type = edge.hasVariableLength() ? PATH : EDGE;</span>

<span class="fc" id="L223">      planTable.add(new PlanTableEntry(type, Sets.newHashSet(edgeVariable), allPredicates,</span>
        new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)));
<span class="fc" id="L225">    }</span>
<span class="fc" id="L226">  }</span>

  //------------------------------------------------------------------------------------------------
  // Join and Expand
  //------------------------------------------------------------------------------------------------

  /**
   * Evaluates which entries in the specified plan table can be joined. The joined entries
   * are added to a new table which is returned.
   *
   * @param currentTable query plan table
   * @return new table containing solely joined plans from the input table
   */
  private PlanTable evaluateJoins(PlanTable currentTable) {
<span class="fc" id="L240">    PlanTable newTable = new PlanTable();</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">    for (int i = 0; i &lt; currentTable.size(); i++) {</span>
<span class="fc" id="L243">      PlanTableEntry leftEntry = currentTable.get(i);</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">      if (mayExtend(leftEntry)) {</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">        for (int j = 0; j &lt; currentTable.size(); j++) {</span>
<span class="fc" id="L246">          PlanTableEntry rightEntry = currentTable.get(j);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">          if (i != j) {</span>
<span class="fc" id="L248">            List&lt;String&gt; joinVariables = getOverlap(leftEntry, rightEntry);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">            if (joinVariables.size() &gt; 0) {</span>
<span class="pc bpc" id="L250" title="1 of 4 branches missed.">              if (rightEntry.getType() == PATH &amp;&amp; joinVariables.size() == 2) {</span>
                // evaluate join with variable length path on source and target vertex
<span class="nc" id="L252">                newTable.add(joinEntries(leftEntry, rightEntry, joinVariables.subList(0, 1)));</span>
<span class="nc" id="L253">                newTable.add(joinEntries(leftEntry, rightEntry, joinVariables.subList(1, 2)));</span>
              } else {
                // regular join or join with variable length path on source or target vertex
<span class="fc" id="L256">                newTable.add(joinEntries(leftEntry, rightEntry, joinVariables));</span>
              }
            }
          }
        }
      }
    }
<span class="fc" id="L263">    return newTable;</span>
  }

  /**
   * Checks if the given entry may be extended. This is only the case for entries that represents
   * either a vertex or a partial match graph.
   *
   * @param entry plan table entry
   * @return true, iff the specified entry may be extended
   */
  private boolean mayExtend(PlanTableEntry entry) {
<span class="fc bfc" id="L274" title="All 4 branches covered.">    return entry.getType() == VERTEX || entry.getType() == GRAPH;</span>
  }

  /**
   * Computes the overlapping query variables of the specified entries.
   *
   * @param firstEntry first entry
   * @param secondEntry second entry
   * @return variables that are available in both input entries
   */
  private List&lt;String&gt; getOverlap(PlanTableEntry firstEntry, PlanTableEntry secondEntry) {
<span class="fc" id="L285">    Set&lt;String&gt; overlap = firstEntry.getAllVariables();</span>
<span class="fc" id="L286">    overlap.retainAll(secondEntry.getAllVariables());</span>
<span class="fc" id="L287">    return new ArrayList&lt;&gt;(overlap);</span>
  }

  /**
   * Joins the query plans represented by the specified plan table entries.
   *
   * The method considers if the right entry is a variable length path and in that case
   * creates an {@link ExpandEmbeddingsNode}. In any other case, a regular
   * {@link JoinEmbeddingsNode} is used to join the query plans.
   *
   * @param leftEntry left entry
   * @param rightEntry right entry
   * @param joinVariables join variables
   * @return an entry that represents the join of both input entries
   */
  private PlanTableEntry joinEntries(PlanTableEntry leftEntry, PlanTableEntry rightEntry,
    List&lt;String&gt; joinVariables) {

    PlanNode node;
<span class="fc bfc" id="L306" title="All 2 branches covered.">    if (rightEntry.getType() == PATH) {</span>
<span class="pc bpc" id="L307" title="2 of 4 branches missed.">      assert joinVariables.size() == 1;</span>
<span class="fc" id="L308">      node = createExpandNode(leftEntry, rightEntry, joinVariables.get(0));</span>
    } else {
<span class="fc" id="L310">      node = new JoinEmbeddingsNode(leftEntry.getQueryPlan().getRoot(),</span>
<span class="fc" id="L311">        rightEntry.getQueryPlan().getRoot(), joinVariables, vertexStrategy, edgeStrategy);</span>
    }

    // update processed variables
<span class="fc" id="L315">    HashSet&lt;String&gt; processedVariables = Sets.newHashSet(leftEntry.getProcessedVariables());</span>
<span class="fc" id="L316">    processedVariables.addAll(rightEntry.getProcessedVariables());</span>
    // create resulting predicates
    // TODO: this might be moved to the join/expand node in issue #510
<span class="fc" id="L319">    CNF predicates = mergePredicates(leftEntry, rightEntry);</span>

<span class="fc" id="L321">    return new PlanTableEntry(GRAPH, processedVariables, predicates,</span>
      new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics));
  }

  /**
   * Creates an {@link ExpandEmbeddingsNode} from the specified arguments.
   *
   * @param leftEntry left entry
   * @param rightEntry right entry
   * @param startVariable vertex variable to expand from
   *
   * @return new expand node
   */
  private ExpandEmbeddingsNode createExpandNode(PlanTableEntry leftEntry, PlanTableEntry rightEntry,
    String startVariable) {

<span class="fc" id="L337">    String pathVariable = rightEntry.getQueryPlan().getRoot()</span>
<span class="fc" id="L338">      .getEmbeddingMetaData().getEdgeVariables().get(0);</span>

<span class="fc" id="L340">    Edge queryEdge = queryHandler.getEdgeByVariable(pathVariable);</span>
<span class="fc" id="L341">    Vertex sourceVertex = queryHandler.getVertexById(queryEdge.getSourceVertexId());</span>
<span class="fc" id="L342">    Vertex targetVertex = queryHandler.getVertexById(queryEdge.getTargetVertexId());</span>

<span class="fc" id="L344">    int lowerBound = queryEdge.getLowerBound();</span>
<span class="fc" id="L345">    int upperBound = queryEdge.getUpperBound();</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">    ExpandDirection direction = sourceVertex.getVariable().equals(startVariable) ?</span>
      ExpandDirection.OUT : ExpandDirection.IN;
<span class="fc bfc" id="L348" title="All 2 branches covered.">    String endVariable = direction == ExpandDirection.OUT ?</span>
<span class="fc" id="L349">      targetVertex.getVariable() : sourceVertex.getVariable();</span>

<span class="fc" id="L351">    return new ExpandEmbeddingsNode(leftEntry.getQueryPlan().getRoot(),</span>
<span class="fc" id="L352">      rightEntry.getQueryPlan().getRoot(),</span>
      startVariable, pathVariable, endVariable, lowerBound, upperBound, direction,
      vertexStrategy, edgeStrategy);
  }

  //------------------------------------------------------------------------------------------------
  // Filter embedding evaluation
  //------------------------------------------------------------------------------------------------

  /**
   * The method checks if a filter can be applied on any of the entries in the specified table. If
   * this is the case, a {@link FilterEmbeddingsNode} is added to the query plan represented by the
   * affected entries.
   *
   * @param currentTable query plan table
   * @return input table with possibly updated entries
   */
  private PlanTable evaluateFilter(PlanTable currentTable) {
<span class="fc" id="L370">    PlanTable newTable = new PlanTable();</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">    for (PlanTableEntry entry : currentTable) {</span>
<span class="fc" id="L373">      Set&lt;String&gt; variables = Sets.newHashSet(entry.getProcessedVariables());</span>
<span class="fc" id="L374">      CNF predicates = entry.getPredicates();</span>
<span class="fc" id="L375">      CNF subCNF = predicates.removeSubCNF(variables);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">      if (subCNF.size() &gt; 0) {</span>
<span class="fc" id="L377">        FilterEmbeddingsNode node = new FilterEmbeddingsNode(entry.getQueryPlan().getRoot(),</span>
          subCNF);
<span class="fc" id="L379">        newTable.add(new PlanTableEntry(GRAPH, Sets.newHashSet(entry.getProcessedVariables()),</span>
          predicates, new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)));
<span class="fc" id="L381">      } else {</span>
<span class="fc" id="L382">        newTable.add(entry);</span>
      }
<span class="fc" id="L384">    }</span>

<span class="fc" id="L386">    return newTable;</span>
  }

  //------------------------------------------------------------------------------------------------
  // Filter embedding evaluation
  //------------------------------------------------------------------------------------------------

  /**
   * The method checks if a filter can be applied on any of the entries in the specified table. If
   * this is the case, a {@link ProjectEmbeddingsNode} is added to the query plan represented by the
   * affected entries.
   *
   * @param currentTable query plan table
   * @return input table with possibly updated entries
   */
  private PlanTable evaluateProjection(PlanTable currentTable) {
<span class="fc" id="L402">    PlanTable newTable = new PlanTable();</span>

<span class="fc bfc" id="L404" title="All 2 branches covered.">    for (PlanTableEntry entry : currentTable) {</span>
<span class="fc" id="L405">      Set&lt;Pair&lt;String, String&gt;&gt; propertyPairs = entry.getPropertyPairs();</span>
<span class="fc" id="L406">      Set&lt;Pair&lt;String, String&gt;&gt; projectionPairs = entry.getProjectionPairs();</span>

<span class="fc" id="L408">      Set&lt;Pair&lt;String, String&gt;&gt; updatedPropertyPairs = propertyPairs.stream()</span>
<span class="fc" id="L409">        .filter(projectionPairs::contains)</span>
<span class="fc" id="L410">        .collect(Collectors.toSet());</span>

<span class="fc bfc" id="L412" title="All 2 branches covered.">      if (updatedPropertyPairs.size() &lt; propertyPairs.size()) {</span>
<span class="fc" id="L413">        ProjectEmbeddingsNode node = new ProjectEmbeddingsNode(entry.getQueryPlan().getRoot(),</span>
          new ArrayList&lt;&gt;(updatedPropertyPairs));
<span class="fc" id="L415">        newTable.add(new PlanTableEntry(GRAPH,</span>
<span class="fc" id="L416">          Sets.newHashSet(entry.getProcessedVariables()), entry.getPredicates(),</span>
          new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)));
<span class="fc" id="L418">      } else {</span>
<span class="fc" id="L419">        newTable.add(entry);</span>
      }
<span class="fc" id="L421">    }</span>
<span class="fc" id="L422">    return newTable;</span>
  }

  //------------------------------------------------------------------------------------------------
  // Join and Expand
  //------------------------------------------------------------------------------------------------

  /**
   * Evaluates which entries in the specified plan table can be joined. The joined entries
   * are added to a new table which is returned.
   *
   * @param currentTable query plan table
   * @return new table containing solely joined plans from the input table
   */
  private PlanTable evaluateCartesianProducts(PlanTable currentTable) {
<span class="fc" id="L437">    PlanTable newTable = new PlanTable();</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">    for (int i = 0; i &lt; currentTable.size(); i++) {</span>
<span class="fc" id="L439">      PlanTableEntry leftEntry = currentTable.get(i);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">      for (int j = i + 1; j &lt; currentTable.size(); j++) {</span>
<span class="fc" id="L441">        PlanTableEntry rightEntry = currentTable.get(j);</span>
<span class="fc" id="L442">        CNF joinPredicate = getJoinPredicate(leftEntry, rightEntry);</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        if (joinPredicate.size() &gt; 0) {</span>
<span class="fc" id="L444">          newTable.add(createValueJoinEntry(leftEntry, rightEntry, joinPredicate));</span>
        } else {
          // regular join or join with variable length path on source or target vertex
<span class="nc" id="L447">          newTable.add(createCartesianProductEntry(leftEntry, rightEntry));</span>
        }
      }
    }
<span class="fc" id="L451">    return newTable;</span>
  }


  /**
   * Computes the overlapping query variables of the specified entries.
   *
   * @param leftEntry first entry
   * @param rightEntry second entry
   * @return variables that are available in both input entries
   */
  private CNF getJoinPredicate(PlanTableEntry leftEntry, PlanTableEntry rightEntry) {
<span class="fc" id="L463">    Set&lt;String&gt; allVariables = leftEntry.getAllVariables();</span>
<span class="fc" id="L464">    allVariables.addAll(rightEntry.getAllVariables());</span>

<span class="fc" id="L466">    CNF leftPredicates = new CNF(leftEntry.getPredicates());</span>
<span class="fc" id="L467">    CNF rightPredicates = new CNF(rightEntry.getPredicates());</span>
<span class="fc" id="L468">    leftPredicates.removeSubCNF(rightEntry.getProcessedVariables());</span>
<span class="fc" id="L469">    rightPredicates.removeSubCNF(leftEntry.getProcessedVariables());</span>
<span class="fc" id="L470">    CNF predicates = leftPredicates.and(rightPredicates).getSubCNF(allVariables);</span>

<span class="fc" id="L472">    return new CNF(</span>
<span class="fc" id="L473">      predicates.getPredicates()</span>
<span class="fc" id="L474">        .stream()</span>
<span class="fc" id="L475">        .filter(p -&gt;</span>
<span class="pc bpc" id="L476" title="2 of 4 branches missed.">          p.size() == 1 &amp;&amp; p.getPredicates().get(0).getComparator().equals(Comparator.EQ)</span>
<span class="fc" id="L477">        ).collect(Collectors.toList())</span>
    );
  }

  /**
   * Creates an {@link CartesianProductNode} from the specified arguments.
   *
   * @param leftEntry left entry
   * @param rightEntry right entry
   *
   * @return new expand node
   */
  private PlanTableEntry createCartesianProductEntry(PlanTableEntry leftEntry,
    PlanTableEntry rightEntry) {
<span class="nc" id="L491">    CartesianProductNode node = new CartesianProductNode(</span>
<span class="nc" id="L492">      leftEntry.getQueryPlan().getRoot(),</span>
<span class="nc" id="L493">      rightEntry.getQueryPlan().getRoot(),</span>
      vertexStrategy, edgeStrategy
    );

<span class="nc" id="L497">    Set&lt;String&gt; processedVariables = leftEntry.getProcessedVariables();</span>
<span class="nc" id="L498">    processedVariables.addAll(rightEntry.getProcessedVariables());</span>

<span class="nc" id="L500">    CNF predicates = mergePredicates(leftEntry, rightEntry);</span>

<span class="nc" id="L502">    return new PlanTableEntry(</span>
      GRAPH,
      processedVariables,
      predicates,
      new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)
    );
  }

  /**
   * Creates an {@link ValueJoinNode} from the specified arguments.
   *
   * @param leftEntry left entry
   * @param rightEntry right entry
   * @param joinPredicate join predicate
   *
   * @return new value join node
   */
  private PlanTableEntry createValueJoinEntry(PlanTableEntry leftEntry,
    PlanTableEntry rightEntry, CNF joinPredicate) {

<span class="fc" id="L522">    List&lt;Pair&lt;String, String&gt;&gt; leftProperties = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L523">    List&lt;Pair&lt;String, String&gt;&gt; rightProperties = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L525" title="All 2 branches covered.">    for (CNFElement e : joinPredicate.getPredicates()) {</span>
<span class="fc" id="L526">      ComparisonExpression comparison = e.getPredicates().get(0);</span>

<span class="fc" id="L528">      Pair&lt;String, String&gt; joinProperty = extractJoinProperty(comparison.getLhs());</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">      if (leftEntry.getAllVariables().contains(joinProperty.getKey())) {</span>
<span class="fc" id="L530">        leftProperties.add(joinProperty);</span>
      } else {
<span class="nc" id="L532">        rightProperties.add(joinProperty);</span>
      }

<span class="fc" id="L535">      joinProperty = extractJoinProperty(comparison.getRhs());</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">      if (leftEntry.getAllVariables().contains(joinProperty.getKey())) {</span>
<span class="nc" id="L537">        leftProperties.add(joinProperty);</span>
      } else {
<span class="fc" id="L539">        rightProperties.add(joinProperty);</span>
      }
<span class="fc" id="L541">    }</span>

<span class="fc" id="L543">    ValueJoinNode node = new ValueJoinNode(</span>
<span class="fc" id="L544">      leftEntry.getQueryPlan().getRoot(),</span>
<span class="fc" id="L545">      rightEntry.getQueryPlan().getRoot(),</span>
      leftProperties, rightProperties,
      vertexStrategy, edgeStrategy
    );

<span class="fc" id="L550">    Set&lt;String&gt; processedVariables = leftEntry.getProcessedVariables();</span>
<span class="fc" id="L551">    processedVariables.addAll(rightEntry.getProcessedVariables());</span>

<span class="fc" id="L553">    CNF predicates = mergePredicates(leftEntry, rightEntry);</span>

<span class="fc" id="L555">    return new PlanTableEntry(</span>
      GRAPH,
      processedVariables,
      predicates,
      new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)
    );
  }

  /**
   * Turns a QueryComparable into a {@code Pair&lt;Variable, PropertyKey&gt;}
   * @param comparable query comparable
   * @return join property
   */
  private Pair&lt;String, String&gt; extractJoinProperty(QueryComparable comparable) {
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">    if (comparable instanceof PropertySelectorComparable) {</span>
<span class="fc" id="L570">      PropertySelectorComparable propertySelector = (PropertySelectorComparable) comparable;</span>
<span class="fc" id="L571">      return Pair.of(propertySelector.getVariable(), propertySelector.getPropertyKey());</span>
    } else {
      //TODO #580 Include ElementSelector -&gt; ID needs to be projected as property
<span class="nc" id="L574">      throw new RuntimeException(&quot;Comparable &quot; + comparable + &quot;cant be used for ValueJoin&quot;);</span>
    }
  }

  /**
   * Creates a new predicate that includes only elements that exist in both input predicates
   *
   * @param leftEntry left side plant table entry
   * @param rightEntry right side plan table entry
   * @return Merged predicates
   */
  private CNF mergePredicates(PlanTableEntry leftEntry, PlanTableEntry rightEntry) {
<span class="fc" id="L586">    CNF leftPredicates = new CNF(leftEntry.getPredicates());</span>
<span class="fc" id="L587">    CNF rightPredicates = new CNF(rightEntry.getPredicates());</span>
<span class="fc" id="L588">    leftPredicates.removeSubCNF(rightEntry.getProcessedVariables());</span>
<span class="fc" id="L589">    rightPredicates.removeSubCNF(leftEntry.getProcessedVariables());</span>
<span class="fc" id="L590">    return leftPredicates.and(rightPredicates);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>